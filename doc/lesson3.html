<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Implementation of Financial Models</title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <link rel="stylesheet" href="main.css" type="text/css">
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    displayAlign: "left",
    displayIndent: "2em",
    "HTML-CSS": {
      preferredFonts: "TeX",
  /*    webFont:"Neo-Euler", */
      undefinedFamily:"'Arial Unicode MS',serif"
    }
  });
  </script>
</head>
<body>
<div id="header">
<h1 class="title"><a href="index.html">Implementation of Financial Models</a></h1>
</div>
<h1 id="lesson-3">Lesson 3</h1>
<blockquote>
<p><i>“I think that object orientedness is almost as much of a hoax as Artificial Intelligence. I have yet to see an interesting piece of code that comes from these OO people.”</i></p>
</blockquote>
<p>Reading: <a href="http://www.stepanovpapers.com/LoRusso_Interview.htm">An Interview with A. Stepanov</a></p>
<p>Complexity is the bane of software engineering and it is best to keep things simple from the start. If you can write something as a global function, do it. If it more than a few lines of code, split it into two or more global functions. Use simple, descriptive names and C++ namespaces to avoid collisions.</p>
<h2 id="root-finding">Root Finding</h2>
<p>Given a function <span class="math">\(f\colon\mathbf{R}\to\mathbf{R}\)</span>, a <em>root</em> is a number <span class="math">\(x\)</span> such that <span class="math">\(f(x) = 0\)</span>. The process of finding a root consists of starting with an initial guess, improving the guess, then deciding when the floating point approximation is good enough.</p>
<p>Finding a good initial guess is half the battle. There is no substitute for knowing things the program doesn’t about the function. The first step is to look at the graph of the function to identify problematic areas.</p>
<p>If the function can be approximated by a function with a simple inverse, that can be used to find a first guess. This is the method used for finding the inverse of the standard normal cumulative distribution, <a href="http://libfms.codeplex.com/SourceControl/latest#prob/normal.h">fms::prob::normal::inv</a></p>
<h3 id="root1d.h"><a href="http://libfms.codeplex.com/SourceControl/latest#root/root1d.h">root1d.h</a></h3>
<p>The <code>fms::root1d</code> namespace has three sub-namespaces: <code>step</code>, <code>done</code>, and <code>find</code>. The <code>step</code> namespace provides various functions for going from current guess(es) for roots to a new guess. If you are wondering why there is an <code>inverse_quadratic</code> instead of <code>quadratic</code> it is because the inverse of a quadratic always has a root.</p>
<p>The <code>done</code> namespace has various tests for convergence. If you can use the <code>done::absolute</code> criterion, that is preferred. It means you are within machine precision of the best root estimate. The problem with using the (seeming) more natural <code>done::residual</code> on the value of the function is that if the slope of the function near the root is close to zero then you may be quite far from the actual root.</p>
<p>The <code>find</code> namespace uses the <code>step</code> and <code>done</code> functions to iterate to a solution. Most commercial libraries have general functions with many parameters that can be used to specify various convergence criteria. We take the simple and pragmatic approach that always attempts to find the best solution to machine precision. The routines <code>find::newton</code> and <code>find::secant</code> call the corresponding <code>step</code> routines. The former typically converges in 4–5 iterations and the latter in 5–6. The secant version can be faster because it makes fewer function calls.</p>
<h1 id="homework">Homework</h1>
<p>Due September 29 at 5pm. Late homework will not be accepted.</p>
<p>Pull a fresh copy of <a href="https://git01.codeplex.com/libfms">libfms</a>.</p>
<p><em>Exercise 1</em>. (25 points) Rewrite the function <code>OPTION.BLACK.VALUE</code> in <code>xllblack.cpp</code> to return a one row array of option value, delta, gamma, vega, and theta. (<em>Hint</em>: See the documentation for the <a href="http://xll.codeplex.com/wikipage?title=FP&amp;referringTitle=Documentation"><code>FP</code></a> data type.)</p>
<p><em>Exercise 2</em>. (25 points) Create a spread sheet that calculates difference quotients to test the output of the routine in Exercise 1. You should parameterize by the bump size. Is there an optimal choice for that?</p>
<p><em>Exercise 3</em>. (25 points) Write the function <code>fms::option::black::implied_volatility</code> in <code>black.h</code> to compute the implied volatility. Provide tests to show your implementation is correct.</p>
<p><em>Exercise 4</em>. (25 points) Implement <code>OPTION.BLACK.IMPLIED.VOLATILITY</code> in <code>xllblack.cpp</code>.</p>
</body>
</html>
